//! Implementation of the `CkField` derive macro.

use crudkit_core_macro_util::{classify_base_type, path_to_string, strip_option_path};
use darling::*;
use proc_macro2::{Ident, Span, TokenStream};
use proc_macro_error::abort;
use proc_macro_type_name::ToTypeName;
use quote::{format_ident, quote};
use syn::{spanned::Spanned, DeriveInput};

#[derive(Debug, FromField)]
#[darling(attributes(ck_field))]
struct MyFieldReceiver {
    ident: Option<syn::Ident>,

    ty: syn::Type,

    convert_ccv: Option<String>,
}

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(ck_field), supports(struct_any))]
struct MyInputReceiver {
    ident: syn::Ident,

    data: ast::Data<(), MyFieldReceiver>,
}

impl MyInputReceiver {
    pub fn fields(&self) -> &ast::Fields<MyFieldReceiver> {
        match &self.data {
            ast::Data::Enum(_) => panic!("Only structs are supported"),
            ast::Data::Struct(fields) => fields,
        }
    }
}

pub fn expand_derive_field(input: DeriveInput) -> syn::Result<TokenStream> {
    let input: MyInputReceiver = FromDeriveInput::from_derive_input(&input)?;

    let name = input.ident.clone();
    let field_enum_name = format_ident!("{}Field", name, span = Span::call_site());

    let fields = input.fields().iter().collect::<Vec<_>>();

    let column_variants = fields
        .iter()
        .map(|field| {
            let ident = field.ident.as_ref().expect("Expected named field!");
            let span = ident.span();
            ident.to_type_ident(span)
        })
        .collect::<Vec<Ident>>();

    // Generate match arms for FieldTrait::name() and FieldLookup::from_name().
    let field_trait_name_arms =
        fields
            .iter()
            .zip(column_variants.iter())
            .map(|(field, variant)| {
                let ident = field.ident.as_ref().expect("Expected named field!");
                quote! { #field_enum_name::#variant => stringify!(#ident) }
            });

    let field_lookup_arms = fields
        .iter()
        .zip(column_variants.iter())
        .map(|(field, variant)| {
            let ident = field.ident.as_ref().expect("Expected named field!");
            quote! { stringify!(#ident) => Some(#field_enum_name::#variant) }
        });

    // Generate match arms for ConditionValueConverter using the same logic as AsColType.
    let condition_value_converter_arms =
        fields
            .iter()
            .zip(column_variants.iter())
            .map(|(field, variant)| {
                let fun_name = match &field.convert_ccv {
                    Some(fun_name) => Ident::new(fun_name.as_str(), field.ident.span()),
                    None => convert_field_type_to_function_name(&field.ty),
                };
                quote! {
                    #field_enum_name::#variant => value.#fun_name()
                }
            });

    Ok(quote! {
        #[doc = "Generated by the `CkField` derive macro (`crudkit-rs-macros`)."]
        #[derive(PartialEq, Eq, Hash, Clone, Debug, serde::Serialize, serde::Deserialize)]
        pub enum #field_enum_name {
            #(#column_variants),*
        }

        // =========================================================================
        // Storage-agnostic traits (crudkit-rs)
        // =========================================================================

        impl crudkit_rs::data::Field for #field_enum_name {
            fn name(&self) -> &'static str {
                match self {
                    #(#field_trait_name_arms),*
                }
            }
        }

        impl crudkit_rs::data::FieldLookup for #field_enum_name {
            fn from_name(name: &str) -> std::option::Option<Self> {
                match name {
                    #(#field_lookup_arms),*,
                    _ => None,
                }
            }
        }

        impl crudkit_rs::data::ConditionValueConverter for #field_enum_name {
            fn convert_condition_value(&self, value: crudkit_rs::crudkit_condition::ConditionClauseValue) -> std::result::Result<crudkit_rs::crudkit_core::Value, String> {
                match self {
                    #(#condition_value_converter_arms),*
                }
            }
        }

        impl crudkit_rs::data::Model for #name {
            type Field = #field_enum_name;
        }
    })
}

/// Converts a field type to the corresponding `ConditionClauseValue` method name.
///
/// Uses the shared `ValueKind` classification from `crudkit_core_macros`.
fn convert_field_type_to_function_name(ty: &syn::Type) -> Ident {
    let span = ty.span();

    let path = match ty {
        syn::Type::Path(type_path) => &type_path.path,
        other => {
            abort!(
                span,
                "crudkit-rs-macros: Unknown type {:?}. Not a 'Path' type. Expected a known type.",
                other;
                help = "Use a supported type path.";
            );
        }
    };

    // Strip Option wrapper if present - the condition methods handle optional transparently.
    let inner_path_str = match strip_option_path(path) {
        Some(inner_ty) => match inner_ty {
            syn::Type::Path(tp) => path_to_string(&tp.path),
            other => {
                abort!(
                    span,
                    "crudkit-rs-macros: Option inner type {:?} is not a path type.",
                    other;
                    help = "Use a supported type path inside Option.";
                );
            }
        },
        None => path_to_string(path),
    };

    // Classify the type and get the method name.
    let kind = classify_base_type(&inner_path_str);

    let method_name = kind.condition_method_name().unwrap_or_else(|| {
        abort!(
            span,
            "crudkit-rs-macros: Unsupported type '{}' for condition value conversion.",
            inner_path_str;
            help = "Supported types: bool, u8-u128, i8-i128, f32, f64, String, \
                    serde_json::Value, uuid::Uuid, time::PrimitiveDateTime, \
                    time::OffsetDateTime, TimeDuration, Vec<u8>";
        );
    });

    Ident::new(method_name, span)
}
