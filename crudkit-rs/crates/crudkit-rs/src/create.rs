use crate::{
    auth::RequestContext,
    collaboration,
    error::CrudError,
    lifetime::CrudLifetime,
    prelude::*,
    validate::{run_entity_validation, run_global_validation},
    validation::{CrudAction, ValidationContext, ValidationTrigger, When},
    GetIdFromModel,
};

use crudkit_core::Saved;
use crudkit_id::Id;
use crudkit_resource::ResourceName;
use crudkit_validation::violation::Violations;
use crudkit_validation::{
    PartialSerializableAggregateViolations, PartialSerializableValidations, ViolationsByEntity,
};

use serde::Deserialize;
use std::{collections::HashMap, sync::Arc};
use utoipa::ToSchema;

#[derive(Debug, ToSchema, Deserialize)]
pub struct CreateOne<T> {
    pub entity: T,
}

#[tracing::instrument(level = "info", skip(context, request))]
pub async fn create_one<R: CrudResource>(
    request: RequestContext<R::Auth>,
    context: Arc<CrudContext<R>>,
    body: CreateOne<R::CreateModel>,
) -> Result<Saved<R::Model>, CrudError> {
    // Use the "CreateModel" to deserialize the given JSON. Some not required members are allowed to be missing.
    let create_model: R::CreateModel = body.entity;

    let create_model_clone = create_model.clone();

    // Directly create an "ActiveModel" from the "CreateModel", ready to be persisted.
    // By not going through the Model -> ActiveModel conversion, we allow the user to exactly specify the data that should be Set/Unset.
    // It is expected that the conversion does not `Set` attributes on the "ActiveModel" that are disallowed in order to run validations.
    // For example: On entities with a standard `id` field, add `#[ck_create_model(exclude)]`, so that the id is not set but always generated by the db.
    let mut active_model: R::ActiveModel = create_model.into_active_model().await;

    let hook_data = R::HookData::default();

    let hook_data = R::Lifetime::before_create(
        &create_model_clone,
        &mut active_model,
        &context.res_context,
        request.clone(),
        hook_data,
    )
    .await
    .map_err(CrudError::from)?;

    // Run validations before inserting the entity. If critical violations are present, prevent the creation!
    let trigger = ValidationTrigger::CrudAction(ValidationContext {
        action: CrudAction::Create,
        when: When::Before,
    });

    let violations_by_validator =
        run_entity_validation::<R>(&context.validators, &active_model, trigger);

    if violations_by_validator.has_critical_violations() {
        // Critical validation errors are returned synchronously in the HTTP response.
        // No websocket broadcast needed - the requesting user gets the error directly.
        return Err(CrudError::CriticalValidationErrors {
            // NOTE: All violations created here do not have an ID, as the entity was not yet saved!
            violations: PartialSerializableAggregateViolations::from(violations_by_validator, None),
        });
    }

    // The entity to insert has no critical violations. The entity can be inserted!
    let inserted_entity: R::Model =
        context
            .repository
            .insert(active_model)
            .await
            .map_err(|err| CrudError::Repository {
                reason: Arc::new(err),
            })?;

    let _hook_data = R::Lifetime::after_create(
        &create_model_clone,
        &inserted_entity,
        &context.res_context,
        request,
        hook_data,
    )
    .await
    .map_err(CrudError::from)?;

    let entity_id = inserted_entity.get_id();
    let serializable_id = entity_id.to_serializable_id();

    // TODO: Performing another conversion into the ActiveModel seems unnecessary. Can we avoid this?
    let active_inserted_entity: R::ActiveModel = inserted_entity.clone().into();

    // Reevaluate the entity for violations and broadcast all of them if some exist.
    let trigger = ValidationTrigger::CrudAction(ValidationContext {
        action: CrudAction::Create,
        when: When::After,
    });

    // TODO: Validate using the model, not the active model? active_inserted_entity would then be obsolete!
    let violations_by_validator =
        run_entity_validation::<R>(&context.validators, &active_inserted_entity, trigger);

    let has_violations = violations_by_validator.has_violations();

    if has_violations {
        // Persist the validation results for later access/use.
        context
            .validation_result_repository
            .save_all(
                R::TYPE.name(),
                ViolationsByEntity::of_entity_violations(
                    entity_id,
                    violations_by_validator.clone(),
                ),
            )
            .await
            .map_err(|err| CrudError::SaveValidations {
                reason: Arc::new(err),
            })?;
    }

    let partial = PartialSerializableAggregateViolations::from(
        violations_by_validator,
        Some(serializable_id.clone()),
    );

    if has_violations {
        // Broadcast the PARTIAL validation result to all registered WebSocket connections.
        // Frontend is responsible to deduplicate for user who initiated this action.
        // We successfully created the entry now.
        // To delete any leftover "create" violations in the frontend, set create to Some empty vector!
        let mut violations = partial.clone();
        violations.create = Some(Violations::empty());

        let partial_serializable_validations: PartialSerializableValidations =
            HashMap::from([(ResourceName::from(R::TYPE.name()), violations)]);

        collaboration::broadcast_partial_validation_result(
            &context,
            partial_serializable_validations,
        )
        .await;
    }

    // Inform all users that the entity was created.
    collaboration::broadcast_creation_event(&context, serializable_id, has_violations).await;

    // Trigger global validation to check system-wide consistency.
    // Results are broadcast via WebSocket to all connected users.
    run_global_validation::<R>(&context).await;

    Ok(Saved {
        entity: inserted_entity,
        violations: partial,
    })
}
