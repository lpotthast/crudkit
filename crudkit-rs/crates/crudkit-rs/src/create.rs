use crate::{
    error::CrudError,
    lifetime::{Abort, CrudLifetime},
    prelude::*,
    validation::{into_persistable, CrudAction, ValidationContext, ValidationTrigger, When},
    GetIdFromModel,
};

use crudkit_id::Id;
use crudkit_shared::{SaveResult, Saved};
use crudkit_validation::PartialSerializableValidations;
use crudkit_websocket::{CkWsMessage, EntityCreated};

use serde::Deserialize;
use snafu::{Backtrace, GenerateImplicitData};
use std::{collections::HashMap, sync::Arc};
use utoipa::ToSchema;

#[derive(Debug, ToSchema, Deserialize)]
pub struct CreateOne<T> {
    pub entity: T,
}

#[tracing::instrument(level = "info", skip(context, res_context))]
pub async fn create_one<R: CrudResource>(
    context: Arc<CrudContext<R>>,
    res_context: Arc<R::Context>,
    body: CreateOne<R::CreateModel>,
) -> Result<SaveResult<R::Model>, CrudError> {
    // Use the "CreateModel" to deserialize the given JSON. Some not required members are allowed to be missing.
    let create_model: R::CreateModel = body.entity;

    let create_model_clone = create_model.clone();

    // Directly create an "ActiveModel" from the "CreateModel", ready to be persisted.
    // By not going through the Model -> ActiveModel conversion, we allow the user to exactly specify the data that should be Set/Unset.
    // It is expected that the conversion does not `Set` attributes on the "ActiveModel" that are disallowed in order to run validations.
    // For example: On entities with a standard `id` field, add `#[ck_create_model(exclude)]`, so that the id is not set but always generated by the db.
    // TODO: Does this still need to be async now that this function no longer takes the context? Probably not..?
    let mut active_model: R::ActiveModel = create_model.into_active_model().await;

    let hook_data = R::HookData::default();
    let (abort, hook_data) = R::Lifetime::before_create(
        &create_model_clone,
        &mut active_model,
        &res_context,
        hook_data,
    )
    .await
    .expect("before_create to no error");

    if let Abort::Yes { reason } = abort {
        return Ok(SaveResult::Aborted { reason });
    }

    // Run validations before inserting the entity. If critical violations are present, prevent the creation!
    // NOTE: All violations created here can not have an ID, as the entity was not yet saved!
    // OPTIMIZATION: We are only interested in CRITICAL violations. Can this be used to make this more efficient?
    let trigger = ValidationTrigger::CrudAction(ValidationContext {
        action: CrudAction::Create,
        when: When::Before,
    });
    let partial_validation_results = context.validator.validate_single(&active_model, trigger);
    if partial_validation_results.has_critical_violations() {
        // TODO: Only notify the user that issued THIS REQUEST!!!
        // Broadcast the PARTIAL validation result to all registered WebSocket connections.
        let partial_serializable_validations: PartialSerializableValidations = HashMap::from([(
            String::from(R::TYPE.into()),
            partial_validation_results.clone().into(),
        )]);
        context
            .ws_controller
            .broadcast_json(CkWsMessage::PartialValidationResult(
                partial_serializable_validations,
            ));

        // NOTE: Nothing must be persisted, as the entity is not yet created!
        return Ok(SaveResult::CriticalValidationErrors);
    }

    // The entity to insert has no critical violations. The entity can be inserted!
    // let inserted_entity: R::Model = build_insert_query::<R>(active_model)?
    //     .exec_with_returning(controller.get_database_connection())
    //     .await
    //     .map_err(|err| CrudError::Db {
    //         reason: err.to_string(),
    //         backtrace: Backtrace::generate(),
    //     })?;

    let inserted_entity: R::Model =
        context
            .repository
            .insert(active_model)
            .await
            .map_err(|err| CrudError::Repository {
                reason: Arc::new(err),
                backtrace: Backtrace::generate(),
            })?;

    let _hook_data = R::Lifetime::after_create(
        &create_model_clone,
        &inserted_entity,
        &res_context,
        hook_data,
    )
    .await;

    let entity_id = inserted_entity.get_id();
    //.expect("Already inserted entities must have an ID!");

    let serializable_id = entity_id.into_serializable_id();

    // TODO: Performing another conversion into the ActiveModel seems unnecessary. Can we avoid this?
    let active_inserted_entity: R::ActiveModel = inserted_entity.clone().into();

    // Reevaluate the entity for violations and broadcast all of them if some exist.
    let trigger = ValidationTrigger::CrudAction(ValidationContext {
        action: CrudAction::Create,
        when: When::After,
    });

    // TODO: Validate using the model, not the active model? active_inserted_entity would then be obsolete!
    let partial_validation_results = context
        .validator
        .validate_single(&active_inserted_entity, trigger);
    let with_validation_errors = partial_validation_results.has_violations();
    if with_validation_errors {
        // Broadcast the PARTIAL validation result to all registered WebSocket connections.
        let mut partial_serializable_validations: PartialSerializableValidations =
            HashMap::from([(
                String::from(R::TYPE.into()),
                partial_validation_results.clone().into(),
            )]);

        // We successfully created the entry at this point. To delete any leftover "create" violations in the frontend, set create to Some empty vector!
        partial_serializable_validations
            .entry(R::TYPE.into().to_owned())
            .and_modify(|s| {
                s.create = Some(Vec::new());
            });

        context
            .ws_controller
            .broadcast_json(CkWsMessage::PartialValidationResult(
                partial_serializable_validations,
            ));

        // Persist the validation results for later access/use.
        let persistable = into_persistable(partial_validation_results);
        context
            .validation_result_repository
            .save_all(persistable)
            .await
            .map_err(|err| CrudError::SaveValidations {
                reason: Arc::new(err),
                backtrace: Backtrace::generate(),
            })?;
    }

    // Inform all participants that the entity was updated.
    // TODO: Exclude the current user!
    context
        .ws_controller
        .broadcast_json(CkWsMessage::EntityCreated(EntityCreated {
            aggregate_name: R::TYPE.into().to_owned(),
            entity_id: serializable_id,
            with_validation_errors,
        }));

    Ok(SaveResult::Saved(Saved {
        entity: inserted_entity,
        with_validation_errors,
    }))
}

// TODO: update_one_and_read_back() which updates and returns a ReadModel instead of an UpdateModel.
