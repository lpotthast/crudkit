//! Implementation of the `CkColumns` derive macro.

use darling::*;
use proc_macro2::{Ident, TokenStream};
use proc_macro_error::abort;
use proc_macro_type_name::ToTypeName;
use quote::quote;
use syn::{spanned::Spanned, DeriveInput};

#[derive(Debug, FromField)]
#[darling(attributes(ck_columns))]
struct MyFieldReceiver {
    ident: Option<syn::Ident>,

    ty: syn::Type,

    convert_ccv: Option<String>,
}

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(ck_columns), supports(struct_any))]
struct MyInputReceiver {
    ident: syn::Ident,

    data: ast::Data<(), MyFieldReceiver>,
}

impl MyInputReceiver {
    pub fn fields(&self) -> &ast::Fields<MyFieldReceiver> {
        match &self.data {
            ast::Data::Enum(_) => panic!("Only structs are supported"),
            ast::Data::Struct(fields) => fields,
        }
    }
}

pub fn expand_derive_columns(input: DeriveInput) -> syn::Result<TokenStream> {
    let input: MyInputReceiver = FromDeriveInput::from_derive_input(&input)?;

    let name = input.ident.clone();

    let fields = input.fields().iter().collect::<Vec<_>>();

    let column_variants = fields
        .iter()
        .map(|field| {
            let ident = field.ident.as_ref().expect("Expected named field!");
            let span = ident.span();
            ident.to_type_ident(span)
        })
        .collect::<Vec<Ident>>();

    // Generate match arms for FieldTrait::name() and FieldLookup::from_name().
    let field_trait_name_arms =
        fields
            .iter()
            .zip(column_variants.iter())
            .map(|(field, variant)| {
                let ident = field.ident.as_ref().expect("Expected named field!");
                quote! { Col::#variant => stringify!(#ident) }
            });

    let field_lookup_arms = fields
        .iter()
        .zip(column_variants.iter())
        .map(|(field, variant)| {
            let ident = field.ident.as_ref().expect("Expected named field!");
            quote! { stringify!(#ident) => Some(Col::#variant) }
        });

    // Generate match arms for ConditionValueConverter using the same logic as AsColType.
    let condition_value_converter_arms =
        fields
            .iter()
            .zip(column_variants.iter())
            .map(|(field, variant)| {
                let fun_name = match &field.convert_ccv {
                    Some(fun_name) => Ident::new(fun_name.as_str(), field.ident.span()),
                    None => convert_field_type_to_function_name(&field.ty),
                };
                quote! {
                    Col::#variant => value.#fun_name()
                }
            });

    Ok(quote! {
        #[doc = "Generated by the `CkColumns` derive macro (`crudkit-rs-macros`)."]
        #[derive(PartialEq, Eq, Hash, Clone, Debug, serde::Serialize, serde::Deserialize)]
        pub enum Col {
            #(#column_variants),*
        }

        // =========================================================================
        // Storage-agnostic traits (crudkit-rs)
        // =========================================================================

        impl crudkit_rs::data::FieldTrait for Col {
            fn name(&self) -> &'static str {
                match self {
                    #(#field_trait_name_arms),*
                }
            }
        }

        impl crudkit_rs::data::FieldLookup for Col {
            fn from_name(name: &str) -> std::option::Option<Self> {
                match name {
                    #(#field_lookup_arms),*,
                    _ => None,
                }
            }
        }

        impl crudkit_rs::data::ConditionValueConverter for Col {
            fn convert_condition_value(&self, value: crudkit_rs::crudkit_condition::ConditionClauseValue) -> std::result::Result<crudkit_rs::crudkit_core::Value, String> {
                match self {
                    #(#condition_value_converter_arms),*
                }
            }
        }

        impl crudkit_rs::data::CrudModel for #name {
            type Field = Col;
        }
    })
}

fn convert_field_type_to_function_name(ty: &syn::Type) -> Ident {
    let span = ty.span();
    // TODO: This should dynamically check types by absolute (resolved) path!
    let fun_name = match ty {
        syn::Type::Path(path) => match join_path(&path.path).as_str() {
            "bool" => "to_bool",
            "Vec<u8>" => "to_byte_vec",
            "u32" => "to_u32",
            "i32" => "to_i32",
            "i64" => "to_i64",
            "f32" => "to_f32",
            "OrderedFloat<f32>" => "to_f32",
            "ordered_float::OrderedFloat<f32>" => "to_f32",
            "f64" => "to_f64",
            "OrderedFloat<f64>" => "to_f64",
            "ordered_float::OrderedFloat<f64>" => "to_f64",
            "String" => "to_string",
            "serde_json::Value" => "to_json_value",
            "uuid::Uuid" => "to_uuid",
            "time::PrimitiveDateTime" => "to_primitive_date_time",
            "time::OffsetDateTime" => "to_offset_date_time",
            "time::Time" => "to_time",
            "Option<u32>" => "to_u32",
            "Option<i32>" => "to_i32",
            "Option<i64>" => "to_i64",
            "Option<String>" => "to_string",
            "Option<serde_json::Value>" => "to_json_value",
            "Option<time::PrimitiveDateTime>" => "to_primitive_date_time",
            "Option<time::OffsetDateTime>" => "to_offset_date_time",
            "Option<TimeDuration>" => "to_time_duration",
            "Option<crudkit_sea_orm::newtypes::TimeDuration>" => "to_time_duration",
            other => {
                let message =
                    format!("crudkit-rs-macros: Unknown type {other:?}. Expected a known type.");
                abort!(
                    span, message;
                    help = "use one of the following types: [...]";
                );
            }
        },
        other => {
            let message = format!(
                "crudkit-rs-macros: Unknown type {other:?}. Not a 'Path' type. Expected a known type."
            );
            abort!(
                span, message;
                help = "use one of the following types: [...]";
            );
        }
    };
    Ident::new(fun_name, span)
}

fn join_path(path: &syn::Path) -> String {
    path.to_token_stream().to_string().replace(' ', "")
}
