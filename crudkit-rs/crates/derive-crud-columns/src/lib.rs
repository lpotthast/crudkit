#![forbid(unsafe_code)]
#![deny(clippy::unwrap_used)]

use darling::*;
use proc_macro::TokenStream;
use proc_macro2::{Ident, Span};
use proc_macro_error::{abort, proc_macro_error};
use proc_macro_type_name::ToTypeName;
use quote::quote;
use syn::{parse_macro_input, spanned::Spanned, DeriveInput};

#[derive(Debug, FromField)]
#[darling(attributes(ck_columns, ck_id))]
struct MyFieldReceiver {
    ident: Option<syn::Ident>,

    ty: syn::Type,

    /// Whether or not this field is part of the entities primary key.
    id: Option<bool>,

    convert_ccv: Option<String>,
}

impl MyFieldReceiver {
    pub fn is_id(&self) -> bool {
        match (self.id, &self.ident) {
            (None, None) => false,
            (None, Some(ident)) => ident == "id",
            (Some(id), None) => id,
            (Some(id), Some(ident)) => id || ident == "id",
        }
    }
}

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(ck_columns, ck_id), supports(struct_any))]
struct MyInputReceiver {
    ident: syn::Ident,

    data: ast::Data<(), MyFieldReceiver>,
}

impl MyInputReceiver {
    pub fn fields(&self) -> &ast::Fields<MyFieldReceiver> {
        match &self.data {
            ast::Data::Enum(_) => panic!("Only structs are supported"),
            ast::Data::Struct(fields) => fields,
        }
    }
}

#[proc_macro_derive(CkColumns, attributes(ck_columns, ck_id))]
#[proc_macro_error]
pub fn store(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);

    let input: MyInputReceiver = match FromDeriveInput::from_derive_input(&ast) {
        Ok(args) => args,
        Err(err) => return darling::Error::write_errors(err).into(),
    };

    let name = input.ident.clone();

    let fields = input.fields().iter().collect::<Vec<_>>();

    let id_fields = input
        .fields()
        .iter()
        .filter(|field| field.is_id())
        .collect::<Vec<_>>();

    let column_variants = fields
        .iter()
        .map(|field| {
            let ident = field.ident.as_ref().expect("Expected named field!");
            let span = ident.span();
            ident.to_type_ident(span)
        })
        .collect::<Vec<Ident>>();

    let init_id_struct_fields_self: Vec<_> = id_fields
        .iter()
        .map(|field| {
            let ident = field.ident.as_ref().expect("Ident to be present").clone();
            // Example: id: self.id.clone()
            quote! { #ident: self.#ident.clone() }
            // TODO: Always clone here?
        })
        .collect();

    // TODO: Use given id ident or fall back to expectable default...
    let id_struct_ident = Ident::new(format!("{}Id", input.ident).as_str(), Span::call_site());

    // Generate match arms for FieldTrait::name() and FieldLookup::from_name().
    let field_trait_name_arms =
        fields
            .iter()
            .zip(column_variants.iter())
            .map(|(field, variant)| {
                let ident = field.ident.as_ref().expect("Expected named field!");
                quote! { Col::#variant => stringify!(#ident) }
            });

    let field_lookup_arms = fields
        .iter()
        .zip(column_variants.iter())
        .map(|(field, variant)| {
            let ident = field.ident.as_ref().expect("Expected named field!");
            quote! { stringify!(#ident) => Some(Col::#variant) }
        });

    // Generate match arms for ConditionValueConverter using the same logic as AsColType.
    let condition_value_converter_arms =
        fields
            .iter()
            .zip(column_variants.iter())
            .map(|(field, variant)| {
                let fun_name = match &field.convert_ccv {
                    Some(fun_name) => Ident::new(fun_name.as_str(), field.ident.span()),
                    None => convert_field_type_to_function_name(&field.ty),
                };
                quote! {
                    Col::#variant => value.#fun_name()
                }
            });

    quote! {
        #[doc = "Generated by the `CkColumns` derive macro (`derive-crud-columns`)."]
        #[derive(PartialEq, Eq, Hash, Clone, Debug, serde::Serialize, serde::Deserialize)]
        pub enum Col {
            #(#column_variants),*
        }

        // =========================================================================
        // Storage-agnostic traits (crudkit-rs)
        // =========================================================================

        impl crudkit_rs::data::FieldTrait for Col {
            fn name(&self) -> &'static str {
                match self {
                    #(#field_trait_name_arms),*
                }
            }
        }

        impl crudkit_rs::data::FieldLookup for Col {
            fn from_name(name: &str) -> std::option::Option<Self> {
                match name {
                    #(#field_lookup_arms),*,
                    _ => None,
                }
            }
        }

        impl crudkit_rs::data::ConditionValueConverter for Col {
            fn convert_condition_value(&self, value: crudkit_rs::crudkit_condition::ConditionClauseValue) -> std::result::Result<crudkit_rs::crudkit_core::Value, String> {
                match self {
                    #(#condition_value_converter_arms),*
                }
            }
        }

        impl crudkit_rs::data::CrudModel for #name {
            type Field = Col;
        }

        impl crudkit_rs::data::CrudIdTrait for #name {
            type Id = #id_struct_ident;

            fn id(&self) -> Self::Id {
                #id_struct_ident {
                    #(#init_id_struct_fields_self),*
                }
            }
        }
    }.into()
}

fn convert_field_type_to_function_name(ty: &syn::Type) -> Ident {
    let span = ty.span();
    // TODO: This should dynamically check types by absolute (resolved) path!
    let fun_name = match ty {
        syn::Type::Path(path) => match join_path(&path.path).as_str() {
            "bool" => "to_bool",
            "Vec<u8>" => "to_byte_vec",
            "u32" => "to_u32",
            "i32" => "to_i32",
            "i64" => "to_i64",
            "f32" => "to_f32",
            "OrderedFloat<f32>" => "to_f32",
            "ordered_float::OrderedFloat<f32>" => "to_f32",
            "f64" => "to_f64",
            "OrderedFloat<f64>" => "to_f64",
            "ordered_float::OrderedFloat<f64>" => "to_f64",
            "String" => "to_string",
            "serde_json::Value" => "to_json_value",
            "uuid::Uuid" => "to_uuid",
            "time::PrimitiveDateTime" => "to_primitive_date_time",
            "time::OffsetDateTime" => "to_offset_date_time",
            "time::Time" => "to_time",
            "Option<u32>" => "to_u32",
            "Option<i32>" => "to_i32",
            "Option<i64>" => "to_i64",
            "Option<String>" => "to_string",
            "Option<serde_json::Value>" => "to_json_value",
            "Option<time::PrimitiveDateTime>" => "to_primitive_date_time",
            "Option<time::OffsetDateTime>" => "to_offset_date_time",
            "Option<TimeDuration>" => "to_time_duration",
            "Option<crudkit_sea_orm::newtypes::TimeDuration>" => "to_time_duration",
            other => {
                let message =
                    format!("derive-crud-columns: Unknown type {other:?}. Expected a known type.");
                abort!(
                    span, message;
                    help = "use one of the following types: [...]";
                );
            }
        },
        other => {
            let message = format!(
                "derive-crud-columns: Unknown type {other:?}. Not a 'Path' type. Expected a known type."
            );
            abort!(
                span, message;
                help = "use one of the following types: [...]";
            );
        }
    };
    Ident::new(fun_name, span)
}

fn join_path(path: &syn::Path) -> String {
    path.to_token_stream().to_string().replace(' ', "")
}
